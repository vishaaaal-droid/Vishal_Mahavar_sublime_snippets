<snippet>
	<content><![CDATA[
const ll MOD = ${0:1e9+7};
class mint{
private:
    ll val; 
public:
    mint(){
        val = 0;
    }
    template<typename T> mint(const T a){
        val = a % MOD;
    }
    mint(const mint &m){
        val = m.val;
    }
    void operator =(const mint &); 
    explicit operator int() const{
        return val;
    }
    explicit operator long long() const{
        return val;
    }
    mint operator +(const mint &); void operator +=(const mint &);
    mint operator -(const mint &); void operator -=(const mint &);
    mint operator *(const mint &); void operator *=(const mint &);
    mint operator /(const mint &); void operator /=(const mint &);
    bool operator ==(const mint &); bool operator <(const mint &);
    bool operator <=(const mint &); bool operator >(const mint &);
    bool operator >=(const mint &); bool operator !=(const mint &); mint operator !(void) const; 
    template<typename T> mint operator ^(T); template<typename T> void operator ^=(T);
    friend istream& operator >>(istream&,mint&); friend ostream& operator <<(ostream&,const mint&);
};

void mint::operator =(const mint &a){
    this->val = a.val;
}

mint mint::operator +(const mint &a){
    mint ans = *this; ans.val += a.val; if(ans.val >= MOD) ans.val -= MOD; return ans;
}

mint mint::operator -(const mint &a){
    mint ans = *this; ans.val -= a.val; if(ans.val < 0) ans.val += MOD; return ans;
}

mint mint::operator *(const mint &a){
    mint ans = *this; ans.val *= a.val; ans.val %= MOD; return ans;
}

mint mint::operator /(const mint &a){
    mint ans = *this; ans *= !a; ans.val %= MOD; return ans;
}

void mint::operator +=(const mint &a){
    *this = (*this) + a;
}

void mint::operator -=(const mint &a){
    *this = (*this) - a;
}

void mint::operator *=(const mint &a){
    *this = (*this) * a;
}

void mint::operator /=(const mint &a){
    *this = (*this) / a;
}

bool mint::operator ==(const mint &a){
    return (this->val == a.val);
}

bool mint::operator <= (const mint &a){
    return (this->val <= a.val);
}

bool mint::operator >= (const mint &a){
    return (this->val >= a.val);
}

bool mint::operator < (const mint &a){
    return (this->val < a.val);
}

bool mint::operator > (const mint &a){
    return (this->val > a.val);
}

bool mint::operator != (const mint &a){
    return (this->val != a.val);
}

mint mint::operator !(void) const{
    mint ans = *this;
    ans^=MOD-2;
    return ans;
}

template<typename T> mint mint::operator ^(T y){
    mint ans = (*this);
    ll res=1;
    while(y)
    {
        if(y&1) res=(res*ans.val)%MOD;
        ans*=ans; y>>=1;
    }
    ans.val = res;
    return ans;
}

template<typename T> void mint::operator ^=(T y){
    (*this) = ((*this)^y);
}

istream& operator >>(istream &in,mint &m){
    return in>>m.val;
}

ostream& operator <<(ostream &out,const mint &m){
 return out<<m.val;
}]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	 <tabTrigger>my_modular</tabTrigger> 
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
